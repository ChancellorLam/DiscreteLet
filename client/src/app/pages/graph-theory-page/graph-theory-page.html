<div class="main-page-container">
  <div class="card flex justify-content-center">
    <p-accordion [(value)]="activeTabs" multiple="true">

      <!--Tab Components-->
      <div class="card">
        <p-tabs [(value)]="activeTab">
          <p-tablist>
            <p-tab value="0">Lessons</p-tab>
            <p-tab value="1">Quizzes</p-tab>
            <p-tab value="2">Unit Tests</p-tab>
          </p-tablist>

          <p-tabpanels>
            <p-tabpanel value="0">
              <h3>Graph Theory Lessons
                <p-button
                  (click)="toggleAll()"
                  styleClass="p-button-text"
                  [label]="isExpanded ? 'Collapse All' : 'Expand All'">
                </p-button>
              </h3>

              <!-- Panel 1 -->
              <p-accordion-panel value="0">
                <p-accordion-header>
                  <div class="topic-header header-font-size">Graph Theory Introduction:</div>
                </p-accordion-header>
                <p-accordion-content>
                  <p class="indent-content">
                    Graph theory is a branch of discrete mathematics that studies graphs. Graphs are structures made of
                    vertices
                    (nodes) and edges (connections). It's a powerful representation for modeling relationships,
                    networks, and interactions across many fields like computer science, mathematics, physics, biology,
                    social science, and more.
                  </p>
                </p-accordion-content>
              </p-accordion-panel>

              <!-- Panel 2 -->
              <p-accordion-panel value="1">
                <p-accordion-header>
                  <div class="topic-header header-font-size">I. Graphs</div>
                </p-accordion-header>
                <p-accordion-content>
                  <div class="indent-content">
                    <p>
                      A graph
                      <app-latex-container
                        [latex]="'G = \\left( V, E \\right)'"
                      ></app-latex-container>
                      consists of:
                    </p>
                    <ul>
                      <li>
                        <app-latex-container
                          [latex]="'V:'"
                        ></app-latex-container>
                        a set of vertices (or nodes)
                      </li>

                      <li>
                        <app-latex-container
                          [latex]="'E:'"
                        ></app-latex-container>
                        a set of edges
                      </li>
                    </ul>
                    <p>Graphs can represent:</p>
                    <ul>
                      <li>
                        computer networks
                      </li>

                      <li>
                        social networks
                      </li>

                      <li>
                        transportation routes
                      </li>

                      <li>
                        molecular structures
                      </li>

                      <li>
                        dependency relationships, and more
                      </li>
                    </ul>
                    Since graphs give us a way to express these ideas as a data structure, we can operate on them using
                    algorithms to do things like find the shortest possible distance from one node to another using an
                    algorithm like
                    breadth-first-search for an unweighted graph or Djakstra's algorithm for a weighted graph.
                  </div>
                </p-accordion-content>
              </p-accordion-panel>

              <!-- Panel 3 -->
              <p-accordion-panel value="2">
                <p-accordion-header>
                  <div class="topic-header header-font-size">II. Types of Graphs</div>
                </p-accordion-header>
                <p-accordion-content>
                  <div class="indent-content">
                    <h3>By direction</h3>
                    <ul>
                      <img
                        ngSrc="images/graphs/undirected_graph.png"
                        alt="undirected_graph"
                        width="608"
                        height="611"
                        class="centered-image"
                      >
                      <li>Undirected graph – edges have no direction</li>
                      <img
                        ngSrc="images/graphs/directed_graph.png"
                        alt="directed_graph"
                        width="608"
                        height="611"
                        class="centered-image"
                      >
                      <li>Directed graph – edges have arrows for one-way relationships</li>
                    </ul>

                    <h3>By weights</h3>
                    <ul>
                      <li>Weighted graph – edges have costs or lengths</li>
                      <li>Unweighted graph – all edges are treated equally</li>
                    </ul>

                    <h3>By structure</h3>
                    <ul>
                      <li>Simple graph – no loops or multiple edges</li>
                      <li>Complete graph – every pair of vertices is connected</li>
                      <li>Bipartite graph – vertices split into two sets with edges only between sets</li>
                      <li>Tree – a graph with a root node</li>
                    </ul>
                  </div>
                </p-accordion-content>
              </p-accordion-panel>

              <!-- Panel 3 -->
              <p-accordion-panel value="2">
                <p-accordion-header>
                  <div class="topic-header header-font-size">III. Some Graph Algorithms</div>
                </p-accordion-header>
                <p-accordion-content>
                  <div class="indent-content">
                    <p>Breadth-First Search (BFS)</p>
                    <p>BFS explores a graph level by level, starting from a source vertex. It visits all neighbors
                      before moving to the next level.</p>
                    <ul>
                      <li>When to use: Best for unweighted graphs to find the shortest path in terms of edges.</li>
                      <li>How it works:
                        <ul>
                          <li>Start by placing the source vertex in a queue.</li>
                          <li>Repeatedly remove a vertex from the front of the queue, visit it, and add all unvisited
                            neighbors to the queue.
                          </li>
                          <li>Continue until all reachable vertices are visited.</li>
                        </ul>
                      </li>
                      <li>Key idea: The first time a vertex is reached, it is via the shortest possible path in number
                        of edges.
                      </li>
                    </ul>

                    <p>Dijkstra's Algorithm</p>
                    <p>Dijkstra's algorithm finds the shortest paths from a source vertex to all other vertices in a
                      weighted graph with non-negative edges.</p>
                    <ul>
                      <li>When to use: Weighted graphs where all edge weights are non-negative.</li>
                      <li>How it works:
                        <ul>
                          <li>Assign a tentative distance to all vertices (0 for source, infinity for others).</li>
                          <li>Set the source as the current vertex.</li>
                          <li>For the current vertex, check all neighbors and update their distances if a shorter path
                            is found.
                          </li>
                          <li>Mark the current vertex as visited and move to the unvisited vertex with the smallest
                            distance.
                          </li>
                          <li>Repeat until all vertices are visited.</li>
                        </ul>
                      </li>
                      <li>Key idea: By always expanding the closest vertex, Dijkstra guarantees the shortest paths to
                        all vertices.
                      </li>
                    </ul>

                    <p>Depth-First Search (DFS)</p>
                    <p>DFS explores a graph by going as deep as possible along each branch before backtracking.</p>
                    <ul>
                      <li>When to use: Useful for exploring all paths, detecting cycles, or solving problems like
                        topological sorting.
                      </li>
                      <li>How it works:
                        <ul>
                          <li>Start at a source vertex and mark it as visited.</li>
                          <li>Recursively visit all unvisited neighbors of the current vertex before backtracking.</li>
                          <li>Continue until all vertices reachable from the source have been visited.</li>
                        </ul>
                      </li>
                      <li>Key idea: DFS goes deep into a branch before exploring other branches, often implemented with
                        recursion or a stack.
                      </li>
                    </ul>

                  </div>
                </p-accordion-content>
              </p-accordion-panel>
            </p-tabpanel>

            <p-tabpanel value="1">
              <h3>Graph Theory Quiz</h3>
              <app-quiz
                [questions]="graphTheoryQuestionPool">
              </app-quiz>
            </p-tabpanel>

            <p-tabpanel value="2">
              <h3>Graph Theory & Unit Test</h3>
              <app-unit-test-template [config]="graphTheoryUnitTestConfig"></app-unit-test-template>
            </p-tabpanel>
          </p-tabpanels>
        </p-tabs>
      </div>
    </p-accordion>
  </div>
</div>
