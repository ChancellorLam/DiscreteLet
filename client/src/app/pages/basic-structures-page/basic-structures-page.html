<div style="display: flex; gap: 10px; margin-bottom: 10px;">
    <p-button
      (click)="toggleAll()"
      styleClass="p-button-text"
      [label]="isExpanded ? 'Collapse All' : 'Expand All'">
    </p-button>
    <p-button
      (click)="clearAll()"
      styleClass="p-button-text p-button-secondary"
      label="Clear All">
    </p-button>
</div>

<div class="card flex justify-content-center">
    <p-accordion [(value)]="activeTabs" multiple="true">

        <!-- Panel 1 -->
        <p-accordion-panel value="0">
            <p-accordion-header>Basic Structure Introduction:</p-accordion-header>
            <p-accordion-content>
                <p class="m-0">
                    Discrete Mathematics revolves around discrete structures that can be counted and separated (i.e numbers, letters, people). One of the important building blocks of basic structures is the set. A set is a collection of things. From sets, we can create things such as combinations, relations, graphs, and even machines. Another concept of basic structures is functions. Functions can either be represented as sequences (such as ordered lists of numbers) or Strings (sequences of symbols). Summations (a word for adding all the numbers together) are also utilized when studying algorithms. The size of sets can also be compared, even infinite sets can be counted and compared. However, other sets may not be countable, like sets of real numbers. This even suggests that there are problems that won't ever be solved by computers. Lastly, there will be matricies (tables of numbers) to help represent and solve problems with relations and graphs.
                </p>
            </p-accordion-content>
        </p-accordion-panel>

        <!-- Panel 2 -->
        <p-accordion-panel value="1">
            <p-accordion-header>1. Sets</p-accordion-header>
            <p-accordion-content>
                <p class="m-0">
                    <strong>Sets</strong> are a simple yet fundamental concept in discrete mathematics. A set is a collection of distinct objects, considered as an object in its own right.
            Sets are typically denoted using curly braces, for example, the set of natural numbers can be represented as &#123;1, 2, 3, ....&#125;.

            The objects within a set are called <strong>elements</strong> or members. Sets can be finite or infinite, and they can contain any type of object, including numbers, letters, or even other sets.

            <br /><br />

            Heres an example of a <strong>numerical set</strong>:

            <br /><br />

            A = &#123;1, 2, 3, 4, 5&#125;

            <br /><br />

            In this example, the set 'A' contains the elements 1, 2, 3, 4, and 5.

            <br /><br />

            Try it yourself using the concept that sets can be numbers, letters, or words:

            <br /><br />

            <p-button
                (click)="loadSetExample1()"
                styleClass="p-button-sm p-button-text"
                label="Load Example: {1, 2, 3, 4, 5}">
            </p-button>
            <p-button
                (click)="generateRandomSet1()"
                styleClass="p-button-sm p-button-text"
                label="Generate Random Set">
            </p-button>

            </p>

            <input
                type="text"
                pInputText
                [(ngModel)]="value1"
                (input)="checkSetInput('value1')"
                placeholder="Enter a valid set:"
                />

                <div *ngIf="isValid1 === null" style="margin-top: 10px;">
                </div>

                <div *ngIf="isValid1 === true" style="color: rgb(110, 241, 110); margin-top: 10px;">
                    Valid set!
                </div>

                <div *ngIf="isValid1 === false && value1.trim() !== ''" style="color: rgb(230, 80, 80); margin-top: 10px;">
                    Invalid set!
                </div>

                <div *ngIf="isValid1 && parsedSet1.length > 0" style="margin-top: 10px; color: rgb(191, 50, 230);">
                    <strong>Your set:</strong> &#123; {{ parsedSet1.join(', ') }} &#125;
                </div>

                <br />

            <p>
                Now that you understand sets, let's move onto set cardinality (the size of sets).

                <br /><br />

                The cardinality of a set is a measure of the "number of elements" in the set. For finite sets, the cardinality is simply the count of distinct elements within the set.

                <br /><br />

                For example, consider the set B = &#123;a, b, c, d&#125;. The cardinality of set B, denoted as |B|, is 4 because there are four distinct elements in the set.

                <br /><br />

                Enter any set to find its cardinality:

                <br /><br />

                <p-button
                    (click)="loadSetExample2()"
                    styleClass="p-button-sm p-button-text"
                    label="Load Example: {a, b, c, d}">
                </p-button>
                <p-button
                    (click)="generateRandomSet2()"
                    styleClass="p-button-sm p-button-text"
                    label="Generate Random Set">
                </p-button>

            </p>

            <input
      type="text"
      pInputText
      [(ngModel)]="value2"
      (input)="checkSetInput('value2')"
      placeholder="Enter a valid set:"
    />

    <div *ngIf="isValid2 === true" style="color: rgb(80, 217, 80); margin-top: 10px;">
      Valid set!
    </div>

    <div *ngIf="isValid2 === false && value2.trim() !== ''" style="color: rgb(230, 80, 80); margin-top: 10px;">
      Invalid set!
    </div>

    <div *ngIf="isValid2 && parsedSet2.length > 0" style="margin-top: 10px; color: rgb(50, 120, 230);">
      <strong>Your set:</strong> &#123; {{ parsedSet2.join(', ') }} &#125;
      <br />
      <strong>Cardinality:</strong> {{ parsedSet2.length }}
    </div>

    <p>
        Lastly, let's briefly go over equivalence of sets.

        <br /><br />

        Two sets are considered equivalent if they have the same cardinality, meaning they contain the same number of elements, regardless of what those elements are.

        <br /><br />

        For example, the sets C = &#123;1, 2, 3&#125; and D = &#123;a, b, c&#125; are equivalent because both sets have a cardinality of 3.

        Using the two sets you entered above, we can check if they are equivalent:

        <br /><br />

        <div *ngIf="isValid1 && isValid2" style="margin-top: 10px;">
            <div *ngIf="parsedSet1.length === parsedSet2.length" style="color: rgb(80, 217, 80);">
                ✓ The sets are equivalent! Both have cardinality {{ parsedSet1.length }}.
            </div>
            <div *ngIf="parsedSet1.length !== parsedSet2.length" style="color: rgb(230, 80, 80);">
                ✗ The sets are not equivalent. Set 1 has cardinality {{ parsedSet1.length }}, Set 2 has cardinality {{ parsedSet2.length }}.
            </div>
        </div>
        <div *ngIf="!(isValid1 && isValid2)" style="color:#f3ba40; margin-top: 10px;">
            Enter valid sets in both fields to check equivalence.
        </div>

    <p style="margin-top: 20px;">
        <strong>Set Operations:</strong> Using the two sets above, perform operations:

        <br /><br />

        <div *ngIf="isValid1 && isValid2" style="margin-top: 10px;">
            <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                <p-button
                    (click)="calculateSetUnion()"
                    label="Union (A ∪ B)"
                    styleClass="p-button-sm">
                </p-button>
                <p-button
                    (click)="calculateSetIntersection()"
                    label="Intersection (A ∩ B)"
                    styleClass="p-button-sm">
                </p-button>
                <p-button
                    (click)="calculateSetDifference()"
                    label="Difference (A - B)"
                    styleClass="p-button-sm">
                </p-button>
                <p-button
                    (click)="checkSubset()"
                    label="Is A ⊆ B?"
                    styleClass="p-button-sm">
                </p-button>
            </div>

            <div *ngIf="setOperationResult.length > 0" style="margin-top: 15px; color: rgb(80, 217, 80);">
                <strong>{{ setOperationLabel }}:</strong> &#123; {{ setOperationResult.join(', ') }} &#125;
            </div>

            <div *ngIf="subsetResult !== null" style="margin-top: 15px;">
                <div *ngIf="subsetResult" style="color: rgb(80, 217, 80);">
                    ✓ Set 1 is a subset of Set 2.
                </div>
                <div *ngIf="!subsetResult" style="color: rgb(230, 80, 80);">
                    ✗ Set 1 is NOT a subset of Set 2.
                </div>
            </div>
        </div>
        <div *ngIf="!(isValid1 && isValid2)" style="color: #f3ba40; margin-top: 10px;">
            Enter valid sets in both fields to perform operations.
        </div>

            </p-accordion-content>
        </p-accordion-panel>

        <!-- Panel 3: Functions -->
        <p-accordion-panel value="3">
            <p-accordion-header>2. Functions</p-accordion-header>
            <p-accordion-content>
                <p class="m-0">
                    A function is a relation between a set of inputs (called the domain) and a set of possible outputs (called the codomain), where each input is related to exactly one output. Functions are fundamental in discrete mathematics and are used to model relationships between different sets.

                    <br /><br />

                    Functions can be represented in various ways:

                    <br /><br />

                    <strong>Sequences:</strong> Ordered lists of numbers, such as (1, 4, 9, 16, 25, ...)

                    <br /><br />

                    <strong>Strings:</strong> Sequences of symbols from an alphabet

                    <br /><br />

                    <strong>Mathematical notation:</strong> f(x) = x², where f maps each input x to its square

                    <br /><br />

                    <strong>Arrow diagrams:</strong> Visual representations showing mappings from domain to codomain

                    <br /><br />

                    <strong>Function Properties:</strong>

                    <br /><br />

                    <strong>One-to-One (Injective):</strong> Each element in the codomain is mapped to by at most one element in the domain. If f(a) = f(b), then a = b.

                    <br /><br />

                    <strong>Onto (Surjective):</strong> Every element in the codomain is mapped to by at least one element in the domain. For every y in the codomain, there exists an x in the domain such that f(x) = y.

                    <br /><br />

                    <strong>Bijective:</strong> A function that is both one-to-one and onto. This means there is a perfect pairing between elements of the domain and codomain.

                    <br /><br />

                    <strong>Example:</strong> Consider the function f: &#123;1, 2, 3&#125; → &#123;a, b, c&#125; defined by:

                    <br /><br />

                    f(1) = a<br />
                    f(2) = b<br />
                    f(3) = c<br />

                    <br />

                    This function is bijective because it is both one-to-one and onto.

                    <br /><br />

                    <strong>Try it yourself:</strong> Enter a function mapping (format: "1:a,2:b,3:c" or "1->a,2->b,3->c"):

                    <br /><br />

                    <p-button
                        (click)="loadFunctionExample()"
                        styleClass="p-button-sm p-button-text"
                        label="Load Example: 1:a,2:b,3:c">
                    </p-button>

                </p>

                <input
                    type="text"
                    pInputText
                    [(ngModel)]="functionInput"
                    (input)="checkFunctionInput()"
                    placeholder="Enter function mapping (e.g., 1:a,2:b,3:c)"
                />

                <div *ngIf="isValidFunction === null" style="margin-top: 10px;">
                </div>

                <div *ngIf="isValidFunction === true" style="color: rgb(110, 241, 110); margin-top: 10px;">
                    Valid function!
                </div>

                <div *ngIf="isValidFunction === false && functionInput.trim() !== ''" style="color: rgb(230, 80, 80); margin-top: 10px;">
                    Invalid function! Use format: "1:a,2:b" or "1->a,2->b"
                </div>

                <div *ngIf="isValidFunction && parsedFunction.length > 0" style="margin-top: 10px; color: rgb(191, 50, 230);">
                    <strong>Your function:</strong><br />
                    <div *ngFor="let pair of parsedFunction" style="margin-left: 20px;">
                        f({{ pair.input }}) = {{ pair.output }}
                    </div>
                </div>

                <div *ngIf="isValidFunction && parsedFunction.length > 0" style="margin-top: 15px;">
                    <p-button
                        (click)="checkFunctionProperties()"
                        label="Check Function Properties"
                        styleClass="p-button-sm">
                    </p-button>

                    <div *ngIf="functionProperties.isInjective !== null" style="margin-top: 15px;">
                        <div *ngIf="functionProperties.isInjective" style="color: rgb(80, 217, 80);">
                            ✓ One-to-One (Injective): Yes
                        </div>
                        <div *ngIf="!functionProperties.isInjective" style="color: rgb(230, 80, 80);">
                            ✗ One-to-One (Injective): No
                        </div>
                        <div *ngIf="functionProperties.isSurjective" style="color: rgb(80, 217, 80); margin-top: 5px;">
                            ✓ Onto (Surjective): Yes
                        </div>
                        <div *ngIf="!functionProperties.isSurjective" style="color: rgb(230, 80, 80); margin-top: 5px;">
                            ✗ Onto (Surjective): No
                        </div>
                        <div *ngIf="functionProperties.isBijective" style="color: rgb(80, 217, 80); margin-top: 5px; font-weight: bold;">
                            ✓ Bijective: Yes (both one-to-one and onto)
                        </div>
                    </div>
                </div>

                <p style="margin-top: 20px;">
                    <strong>Function Composition:</strong> Enter a second function to compose:

                    <br /><br />

                    <input
                        type="text"
                        pInputText
                        [(ngModel)]="function2Input"
                        (input)="checkFunction2Input()"
                        placeholder="Enter second function (e.g., a:1,b:2,c:3)"
                        style="width: 100%; max-width: 400px;"
                    />

                    <div *ngIf="isValidFunction2 && parsedFunction2.length > 0" style="margin-top: 10px; color: rgb(50, 120, 230);">
                        <strong>Function g:</strong><br />
                        <div *ngFor="let pair of parsedFunction2" style="margin-left: 20px;">
                            g({{ pair.input }}) = {{ pair.output }}
                        </div>
                    </div>

                    <div *ngIf="isValidFunction && isValidFunction2 && parsedFunction.length > 0 && parsedFunction2.length > 0" style="margin-top: 15px;">
                        <p-button
                            (click)="composeFunctions()"
                            label="Compose Functions (f ∘ g)"
                            styleClass="p-button-sm">
                        </p-button>

                        <div *ngIf="composedFunction.length > 0" style="margin-top: 15px; color: rgb(80, 217, 80);">
                            <strong>Composition (f ∘ g):</strong><br />
                            <div *ngFor="let pair of composedFunction" style="margin-left: 20px;">
                                (f ∘ g)({{ pair.input }}) = {{ pair.output }}
                            </div>
                        </div>
                        <div *ngIf="compositionError" style="margin-top: 15px; color: rgb(230, 80, 80);">
                            {{ compositionError }}
                        </div>
                    </div>


            </p-accordion-content>
        </p-accordion-panel>

        <!-- Panel 4: Matrices -->
        <p-accordion-panel value="4">
            <p-accordion-header>3. Matrices</p-accordion-header>
            <p-accordion-content>
                <p class="m-0">
                    A matrix is a rectangular array of numbers arranged in rows and columns. Matrices are used to represent and solve problems with relations and graphs in discrete mathematics.

                    <br /><br />

                    A matrix with m rows and n columns is called an m × n matrix. The numbers in a matrix are called entries or elements.

                    <br /><br />

                    <strong>Example:</strong> Here is a 2 × 3 matrix:

                    <br /><br />

                    A = [1  2  3]<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;[4  5  6]

                    <br /><br />

                    This matrix has 2 rows and 3 columns.

                    <br /><br />

                    <strong>Matrix Operations:</strong>

                    <br /><br />

                    <strong>Matrix Addition:</strong> Two matrices can be added if they have the same dimensions. You add corresponding entries.

                    <br /><br />

                    <strong>Example:</strong><br />
                    [1  2] + [5  6] = [6  8]<br />
                    [3  4]&nbsp;&nbsp;[7  8]&nbsp;&nbsp;[10 12]

                    <br /><br />

                    <strong>Matrix Multiplication:</strong> To multiply two matrices, the number of columns in the first matrix must equal the number of rows in the second matrix.

                    <br /><br />

                    <strong>Try it yourself:</strong> Enter two matrices to add them (format: "1,2;3,4" for a 2x2 matrix, rows separated by semicolons):

                </p>

                <p style="margin-top: 15px;"><strong>Matrix A:</strong></p>
                <input
                    type="text"
                    pInputText
                    [(ngModel)]="matrixAInput"
                    (input)="checkMatrixInput('A')"
                    placeholder="Enter matrix A (e.g., 1,2;3,4)"
                    style="width: 100%; max-width: 400px;"
                />

                <div *ngIf="isValidMatrixA === true" style="color: rgb(110, 241, 110); margin-top: 10px;">
                    Valid matrix A!
                </div>

                <div *ngIf="isValidMatrixA === false && matrixAInput.trim() !== ''" style="color: rgb(230, 80, 80); margin-top: 10px;">
                    Invalid matrix A! Use format: "1,2;3,4" (rows separated by semicolons)
                </div>

                <div *ngIf="isValidMatrixA && matrixA.length > 0" style="margin-top: 10px; color: rgb(50, 120, 230);">
                    <strong>Matrix A:</strong> {{ matrixA.length }} × {{ matrixA.length > 0 ? matrixA[0].length : 0 }} matrix<br />
                    <div *ngFor="let row of matrixA" style="margin-left: 20px;">
                        [ {{ row.join('  ') }} ]
                    </div>
                </div>

                <p style="margin-top: 15px;"><strong>Matrix B:</strong></p>
                <input
                    type="text"
                    pInputText
                    [(ngModel)]="matrixBInput"
                    (input)="checkMatrixInput('B')"
                    placeholder="Enter matrix B (e.g., 5,6;7,8)"
                    style="width: 100%; max-width: 400px;"
                />

                <div *ngIf="isValidMatrixB === true" style="color: rgb(110, 241, 110); margin-top: 10px;">
                    Valid matrix B!
                </div>

                <div *ngIf="isValidMatrixB === false && matrixBInput.trim() !== ''" style="color: rgb(230, 80, 80); margin-top: 10px;">
                    Invalid matrix B! Use format: "1,2;3,4" (rows separated by semicolons)
                </div>

                <div *ngIf="isValidMatrixB && matrixB.length > 0" style="margin-top: 10px; color: rgb(50, 120, 230);">
                    <strong>Matrix B:</strong> {{ matrixB.length }} × {{ matrixB.length > 0 ? matrixB[0].length : 0 }} matrix<br />
                    <div *ngFor="let row of matrixB" style="margin-left: 20px;">
                        [ {{ row.join('  ') }} ]
                    </div>
                </div>

                <div *ngIf="isValidMatrixA" style="margin-top: 20px;">
                    <p style="margin-bottom: 10px;"><strong>Matrix A Operations:</strong></p>
                    <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                        <input
                            type="number"
                            pInputText
                            [(ngModel)]="scalarValue"
                            placeholder="Enter scalar value"
                            style="width: 150px;"
                        />
                        <p-button
                            (click)="multiplyByScalar('A')"
                            label="Multiply A by Scalar"
                            styleClass="p-button-sm">
                        </p-button>
                        <p-button
                            (click)="transposeMatrix('A')"
                            label="Transpose A"
                            styleClass="p-button-sm">
                        </p-button>
                    </div>

                    <div *ngIf="scalarResult.length > 0" style="margin-top: 15px; color: rgb(80, 217, 80);">
                        <strong>Scalar Multiplication Result:</strong><br />
                        <div *ngFor="let row of scalarResult" style="margin-left: 20px;">
                            [ {{ row.join('  ') }} ]
                        </div>
                    </div>

                    <div *ngIf="transposeResult.length > 0" style="margin-top: 15px; color: rgb(80, 217, 80);">
                        <strong>Transpose Result:</strong><br />
                        <div *ngFor="let row of transposeResult" style="margin-left: 20px;">
                            [ {{ row.join('  ') }} ]
                        </div>
                    </div>
                </div>

                <div *ngIf="isValidMatrixA && isValidMatrixB" style="margin-top: 20px;">
                    <p style="margin-bottom: 10px;"><strong>Matrix Operations:</strong></p>
                    <div style="display: flex; gap: 5px;">
                        <p-button
                            (click)="addMatrices()"
                            label="Add (A + B)"
                            styleClass="p-button-sm">
                        </p-button>
                        <p-button
                            (click)="multiplyMatrices()"
                            label="Multiply (A × B)"
                            styleClass="p-button-sm">
                        </p-button>
                    </div>

                    <div *ngIf="matrixSum.length > 0" style="margin-top: 15px; color: rgb(80, 217, 80);">
                        <strong>Result (A + B):</strong><br />
                        <div *ngFor="let row of matrixSum" style="margin-left: 20px;">
                            [ {{ row.join('  ') }} ]
                        </div>
                    </div>

                    <div *ngIf="matrixProduct.length > 0" style="margin-top: 15px; color: rgb(80, 217, 80);">
                        <strong>Result (A × B):</strong><br />
                        <div *ngFor="let row of matrixProduct" style="margin-left: 20px;">
                            [ {{ row.join('  ') }} ]
                        </div>
                    </div>

                    <div *ngIf="matrixError" style="margin-top: 15px; color: rgb(230, 80, 80);">
                        {{ matrixError }}
                    </div>
                </div>

                <div style="margin-top: 20px;">
                    <p-button
                        (click)="loadMatrixExample()"
                        styleClass="p-button-sm p-button-text"
                        label="Load Example Matrices">
                    </p-button>
                </div>

            </p-accordion-content>
        </p-accordion-panel>

    </p-accordion>
</div>

